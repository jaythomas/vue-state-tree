import assert from 'assert'
import chalk from 'chalk'
import flushPromises from 'flush-promises'
import Vue from 'vue'
import { model, types as t } from './index.js'

Vue.config.devtools = false
Vue.config.productionTip = false
// Hide clutter generated by our smoke alarm tests
Vue.config.warnHandler = () => {}

function weatherData() {
  return {
    name: 'weather',
    data() {
      return {
        temperature: 50
      }
    },
    computed: {
      celsius: {
        get() {
          return Math.trunc((this.temperature - 32) / 1.8)
        },
        set(value) {
          return this.temperature = Math.trunc(value * 1.8 + 32)
        }
      }
    },
    methods: {
      incrementTemperature() {
        this.temperature += 0.5
      }
    }
  }
}

test('instantiates a model with data, computed properties, and methods', () => {
  const instance = model(weatherData())
  assert.strictEqual(instance.temperature, 50, 'store data exists directly on the view model')
  assert.strictEqual(instance.celsius, 10, 'computed properties exists directly on the view model')
  assert.strictEqual(typeof instance.incrementTemperature, 'function', 'methods exists directly on the view model')
})

test('allows direct data mutations when the immutable option is false', () => {
  const instance = model(weatherData(), { immutable: false })
  instance.temperature = 32
  assert.strictEqual(instance.celsius, 0, 'temperature should have been directly mutated')
})


//
// Type checking
//

function programmerData() {
  return {
    name: 'programmer',
    data: {
      firstName: 'Brian',
      lastName: 'Kernighan',
      language: 'C'
    },
    computed: {
      fullName: {
        get() {
          return this.firstName + ' ' + this.lastName
        },
        set(value) {
          [this.firstName, this.lastName ] = value.split(' ')
        }
      }
    },
    methods: {
      setFirstName(value) {
        this.firstName = value
      }
    },
    schema: {
      firstName: t.string,
      lastName: t.string,
      language: t.enum('AMPL', 'AWK', 'B', 'C')
    }
  }
}

test('checks data on instantiation', async () => {
  assert(model(programmerData()), 'schema should be ok the way it was originally defined')
  try {
    data.schema.language = t.enum('Erlang', 'Elixir')
    model(data)
    await flushPromises()
    assert(false, 'got no error from type checking when we expected it')
  } catch(err) {
    assert(err, 'language property should fail type checking')
  }
})

test('should not error out for items missing from the schema', async () => {
  const data = programmerData()
  delete data.schema.lastName
  model(data)
  await flushPromises()
  assert(true, 'lastName not in schema but should be no problemo')
})

async function test(description, fn) {
  try {
    await fn()
    console.log(chalk.green.underline('✓ ' + description))
  } catch(error) {
    console.log(chalk.red.underline('❌ ' + description))
    console.log(chalk.red(error.message))
  }
}
